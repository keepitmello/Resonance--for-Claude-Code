# 로그 예제

사이클 로그 작성을 위한 참고 예제입니다. 템플릿이 아닌 스토리텔링에 집중하세요.

## 좋은 로그 예제 - 결제 API 구현

```markdown
## 🔄 사이클 #12 - 결제 API 통합

**작성**: 2025-01-07 15:28:06  
**상태**: ⚠️ 부분 완료 (동시성 처리 미완성)

### 📝 구현 요약

부분적인 동시성 보호와 함께 Stripe 결제 통합을 구현했다.

**주요 변경사항**:
```diff
+ src/services/PaymentService.ts (신규)
+ src/webhooks/stripe.ts (신규)
+ test/payment.test.ts (신규)
~ src/routes/api.ts (수정: 결제 라우트 추가)
```

### 🧪 TDD 프로세스 & 테스트 결과

**TDD 사이클 준수**: ✅ 예

#### 🔴 RED 단계
결제 동작을 정의하는 8개 테스트를 먼저 작성했다. 예상대로 모두 실패했다.

#### 🟢 GREEN 단계
테스트 통과를 위한 최소 구현을 했다. Stripe 응답 모킹이 예상보다 오래 걸렸다.

#### 🔵 REFACTOR 단계
검증 로직을 별도 함수로 추출했다. 에러 메시지를 개선했다.

**최종 커버리지**: 87.5%

### 💭 주요 결정사항

**Redis 대신 PostgreSQL Advisory Lock**
Redis 의존성을 추가하는 대신 기존 PostgreSQL 인프라를 사용하기로 선택했다. 성능은 약간 느리지만(50ms vs 20ms) 운영 복잡도는 훨씬 낮다.

### 🤔 직면한 도전과제

**중복 결제 방지**
처음에는 낙관적 락을 시도했지만 부하 상황에서 레이스 컨디션이 발생했다. Advisory Lock으로 전환해 문제를 해결했지만 신중한 트랜잭션 관리가 필요했다.

### 🚨 미해결 이슈

1. **타임아웃 처리**: 장시간 결제에 대한 더 나은 접근법 필요
2. **배치 처리**: 현재 구현은 대량 작업에 느림

### 📈 측정 지표

- 단일 결제: 평균 150ms
- 동시 처리: 최대 500 TPS
- 에러율: 0.2% (대부분 타임아웃)

### 🔄 다음 단계

Opus의 가이드가 필요한 부분:
- 배치 처리 아키텍처
- 타임아웃 처리 전략
- 더 나은 성능을 위한 Redis 추가 여부
```

## 좋은 로그의 특징

1. **사실적 톤** - "놀라운 X를 성공적으로 구축!" 대신 "X를 구현했다"
2. **구체적 지표** - 모호한 설명이 아닌 실제 숫자
3. **솔직한 도전과제** - 실제로 무엇이 잘못되었고 왜 그랬는지
4. **명확한 결정사항** - 무엇을 선택했고 그 이유
5. **실행 가능한 다음 단계** - 구체적인 질문이나 차단 요소

## 피해야 할 것

❌ "완벽하게 결제 시스템을 구현했습니다!"  
✅ "결제 검증을 구현했다. 8개 중 7개 테스트 통과."

❌ "모든 것이 훌륭하게 작동합니다!"  
✅ "기본 플로우는 작동한다. 동시 요청에서 이슈 있음."

❌ 긴 템플릿 같은 섹션  
✅ 무슨 일이 일어났는지의 자연스러운 내러티브